#!/bin/bash
{{- $os_id := .chezmoi.osRelease.id }}
{{- if or (eq $os_id "pop") (eq $os_id "ubuntu") }}

# This comment includes the hash of packages to track changes
# Packages hash: {{ include ".chezmoidata/packages.yaml" | sha256sum }}

set -e

echo "üõ†Ô∏è Installing development tools..."

# Utilities
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

install_apt_package() {
    local package="$1"
    echo "Installing $package..."
    if sudo apt install -y "$package" 2>/dev/null; then
        echo "‚úÖ $package installed"
    else
        echo "‚ö†Ô∏è Failed to install $package via apt"
        return 1
    fi
}

# General-purpose simple YAML section parser
parse_yaml_list() {
    local file="$1"
    local path="$2"
    local in_target_section=false
    local current_depth=0
    local target_indent=0
    
    IFS='.' read -ra keys <<< "$path"
    local max_depth=${#keys[@]}

    while IFS= read -r line || [ -n "$line" ]; do
        # Skip comments and empty lines
        [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
        
        # Calculate indentation
        local indent=$(echo "$line" | sed 's/[^ ].*//' | wc -c)
        indent=$((indent - 1))
        
        # Clean line for matching
        local clean=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        
        # Check if we're matching the current key in our path
        if [[ "$clean" == "${keys[$current_depth]}:" ]]; then
            if [[ $current_depth -eq $((max_depth - 1)) ]]; then
                # We've reached our target section
                in_target_section=true
                target_indent=$indent
            else
                # Move to next depth
                current_depth=$((current_depth + 1))
            fi
            continue
        fi
        
        # If we're in target section and hit a line with same or less indentation that's a key, we're done
        if [[ "$in_target_section" == true ]] && [[ $indent -le $target_indent ]] && [[ "$clean" =~ ^[a-zA-Z0-9_-]+: ]]; then
            break
        fi
        
        # Extract list items from target section
        if [[ "$in_target_section" == true ]] && [[ "$clean" == -* ]]; then
            echo "$clean" | sed -E 's/^- +//' | sed 's/^["'"'"']//;s/["'"'"']$//'
        fi
        
        # Reset if we've moved to a different top-level section
        if [[ $indent -eq 0 ]] && [[ "$clean" =~ ^[a-zA-Z0-9_-]+: ]] && [[ "$clean" != "${keys[0]}:" ]]; then
            current_depth=0
            in_target_section=false
        fi
        
    done < "$file"
}

# Parse install scripts from development section
parse_install_scripts() {
    local file="$1"
    local in_development=false
    local in_install_scripts=false
    local name="" url="" args=""

    while IFS= read -r line || [ -n "$line" ]; do
        # Skip comments and empty lines
        [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
        
        local clean=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        local indent=$(echo "$line" | sed 's/[^ ].*//' | wc -c)
        indent=$((indent - 1))

        # Track development section
        if [[ "$clean" == "development:" ]]; then
            in_development=true
            continue
        fi
        
        # Exit development if we hit another top-level section
        if [[ $indent -eq 0 ]] && [[ "$clean" =~ ^[a-zA-Z0-9_-]+: ]] && [[ "$clean" != "development:" ]]; then
            in_development=false
            continue
        fi

        # Track install_scripts subsection
        if [[ "$in_development" == true ]] && [[ "$clean" == "install_scripts:" ]]; then
            in_install_scripts=true
            continue
        fi

        # Parse script entries
        if [[ "$in_install_scripts" == true ]]; then
            if [[ "$clean" == -*name:* ]]; then
                # Output previous script if complete
                [[ -n "$name" && -n "$url" ]] && echo "$name|$url|$args"
                name=$(echo "$clean" | cut -d: -f2- | sed 's/^ *//;s/^["'"'"']//;s/["'"'"']$//')
                url="" args=""
            elif [[ "$clean" == url:* ]]; then
                url=$(echo "$clean" | cut -d: -f2- | sed 's/^ *//;s/^["'"'"']//;s/["'"'"']$//')
            elif [[ "$clean" == args:* ]]; then
                args=$(echo "$clean" | cut -d: -f2- | sed 's/^ *//;s/^["'"'"']//;s/["'"'"']$//')
            fi
        fi
    done < "$file"

    # Output last script if complete
    [[ -n "$name" && -n "$url" ]] && echo "$name|$url|$args"
}

# Main installation logic
PACKAGES_FILE="{{ .chezmoi.sourceDir }}/.chezmoidata/packages.yaml"

if [[ ! -f "$PACKAGES_FILE" ]]; then
    echo "‚ùå Packages file not found: $PACKAGES_FILE"
    exit 1
fi

echo "üì¶ Updating system packages..."
sudo apt update

# Install APT packages
echo "üì¶ Installing APT packages..."
while IFS= read -r pkg; do
    [[ -n "$pkg" ]] && install_apt_package "$pkg" || true
done < <(parse_yaml_list "$PACKAGES_FILE" "ubuntu.apt")

# Install Snap packages (regular)
echo "üì¶ Installing Snap packages (regular)..."
while IFS= read -r pkg; do
    if [[ -n "$pkg" ]]; then
        echo "Installing $pkg via snap..."
        if command_exists snap && sudo snap install "$pkg" 2>/dev/null; then
            echo "‚úÖ $pkg installed (snap)"
        else
            echo "‚ö†Ô∏è Failed to install $pkg via snap"
        fi
    fi
done < <(parse_yaml_list "$PACKAGES_FILE" "ubuntu.snap.regular")

# Install Snap packages (classic)
echo "üì¶ Installing Snap packages (classic)..."
while IFS= read -r pkg; do
    if [[ -n "$pkg" ]]; then
        echo "Installing $pkg via snap --classic..."
        if command_exists snap && sudo snap install "$pkg" --classic 2>/dev/null; then
            echo "‚úÖ $pkg installed (snap classic)"
        else
            echo "‚ö†Ô∏è Failed to install $pkg via snap --classic"
        fi
    fi
done < <(parse_yaml_list "$PACKAGES_FILE" "ubuntu.snap.classic")

# Install Flatpak packages
echo "üì¶ Installing Flatpak packages..."
FLATPAK_PACKAGES=$(parse_yaml_list "$PACKAGES_FILE" "ubuntu.flatpak")
if [[ -n "$FLATPAK_PACKAGES" ]]; then
    # Ensure flatpak is installed
    if ! command_exists flatpak; then
        install_apt_package flatpak
        sudo flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo
    fi
    
    echo "$FLATPAK_PACKAGES" | while IFS= read -r pkg; do
        if [[ -n "$pkg" ]]; then
            echo "Installing $pkg via flatpak..."
            if sudo flatpak install -y flathub "$pkg" 2>/dev/null; then
                echo "‚úÖ $pkg installed (flatpak)"
            else
                echo "‚ö†Ô∏è Failed to install $pkg via flatpak"
            fi
        fi
    done
else
    echo "‚ÑπÔ∏è No Flatpak packages specified, skipping..."
fi

# Install development tools via install scripts
echo "üì¶ Installing development tools via install scripts..."
while IFS="|" read -r name url args; do
    if [[ -n "$name" && -n "$url" ]]; then
        if ! command_exists "$name"; then
            echo "Installing $name..."
            if [[ "$args" == *"| sh"* ]]; then
                curl -fsSL "$url" | sh
            elif [[ -n "$args" ]]; then
                curl -fsSL "$url" | sh $args
            else
                curl -fsSL "$url" | sh
            fi
            
            if [[ $? -eq 0 ]]; then
                echo "‚úÖ $name installed successfully"
            else
                echo "‚ö†Ô∏è Failed to install $name"
            fi
        else
            echo "‚ÑπÔ∏è $name is already installed, skipping..."
        fi
    fi
done < <(parse_install_scripts "$PACKAGES_FILE")

# Post-installation fixes
echo "üîß Applying post-installation fixes..."

# Create fd symlink if fd-find was installed
if command_exists fdfind && [[ ! -f /usr/local/bin/fd ]]; then
    sudo ln -s /usr/bin/fdfind /usr/local/bin/fd
    echo "‚úÖ Created fd symlink for fdfind"
fi

# Source cargo environment if rust was installed
if [[ -f "$HOME/.cargo/env" ]]; then
    source "$HOME/.cargo/env"
    echo "‚úÖ Sourced Rust/Cargo environment"
fi

echo "‚úÖ Development tools installation complete!"
echo "‚ÑπÔ∏è Some changes may require a logout/login or shell restart to take effect."

{{- end }}