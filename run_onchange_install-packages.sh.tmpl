#!/bin/bash
{{- $os_id := .chezmoi.osRelease.id }}
{{- if or (eq $os_id "pop") (eq $os_id "ubuntu") }}

# This comment includes the hash of packages to track changes
# Packages hash: {{ include ".chezmoidata/packages.yaml" | sha256sum }}

set -e

echo "üõ†Ô∏è Installing development tools..."

# Function to check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Function to install via apt with error handling
install_apt_package() {
    local package=$1
    echo "Installing $package..."
    if sudo apt install -y "$package" 2>/dev/null; then
        echo "‚úÖ $package installed successfully"
    else
        echo "‚ö†Ô∏è Failed to install $package via apt (package may not exist)"
        return 1
    fi
}

# Function to parse YAML section using pure bash
parse_yaml_section() {
    local file=$1
    local section=$2
    local in_section=false
    local packages=()
    
    if [ ! -f "$file" ]; then
        return 1
    fi
    
    while IFS= read -r line; do
        # Remove leading/trailing whitespace
        line=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        
        # Skip empty lines and comments
        [[ -z "$line" || "$line" =~ ^# ]] && continue
        
        # Check if we're entering the desired section
        if [[ "$line" == "$section:" ]]; then
            in_section=true
            continue
        fi
        
        # Check if we're entering a different section (exit current section)
        if [[ "$line" =~ ^[a-zA-Z_][a-zA-Z0-9_]*: ]] && [[ "$in_section" == true ]]; then
            break
        fi
        
        # If we're in the section and line starts with "  -", extract package name
        if [[ "$in_section" == true && "$line" =~ ^-[[:space:]]+ ]]; then
            package=$(echo "$line" | sed 's/^-[[:space:]]*//' | sed "s/^['\"]//;s/['\"]$//")
            packages+=("$package")
        fi
    done < "$file"
    
    # Return packages as space-separated string
    printf '%s\n' "${packages[@]}"
}

# Function to parse nested YAML section (for snap regular/classic)
parse_nested_yaml_section() {
    local file=$1
    local parent_section=$2
    local child_section=$3
    local in_parent=false
    local in_child=false
    local packages=()
    
    if [ ! -f "$file" ]; then
        return 1
    fi
    
    while IFS= read -r line || [ -n "$line" ]; do
        # Skip empty lines and comments
        [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
        
        # Check for parent section (no leading spaces)
        if [[ "$line" == "$parent_section:" ]]; then
            in_parent=true
            in_child=false
            continue
        fi
        
        # Exit if we hit another top-level section
        if [[ "$line" =~ ^[a-zA-Z_][a-zA-Z0-9_]*:[[:space:]]*$ ]] && [[ "$in_parent" == true ]]; then
            break
        fi
        
        # Check for child section (2 spaces)
        if [[ "$in_parent" == true && "$line" == "  $child_section:" ]]; then
            in_child=true
            continue
        fi
        
        # Exit child if we hit another child section
        if [[ "$in_parent" == true && "$line" =~ ^[[:space:]]{2}[a-zA-Z_][a-zA-Z0-9_]*:[[:space:]]*$ ]]; then
            in_child=false
            continue
        fi
        
        # Extract packages (4 spaces + dash)
        if [[ "$in_child" == true && "$line" =~ ^[[:space:]]{4}-[[:space:]] ]]; then
            package="${line#        - }"
            package="${package#\'}"
            package="${package%\'}"
            package="${package#\"}"
            package="${package%\"}"
            [[ -n "$package" ]] && packages+=("$package")
        fi
    done < "$file"
    
    printf '%s\n' "${packages[@]}"
}

# Function to parse install scripts from development section
parse_install_scripts() {
    local file=$1
    local in_development=false
    local in_install_scripts=false
    local current_name=""
    local current_url=""
    local current_args=""
    local scripts=()
    
    if [ ! -f "$file" ]; then
        return 1
    fi
    
    while IFS= read -r line || [ -n "$line" ]; do
        # Skip empty lines and comments
        [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
        
        # Check for development section
        if [[ "$line" =~ ^[[:space:]]*development:[[:space:]]*$ ]]; then
            in_development=true
            in_install_scripts=false
            continue
        fi
        
        # Exit development section if we hit another top-level section
        if [[ "$line" =~ ^[[:space:]]*[a-zA-Z_][a-zA-Z0-9_]*:[[:space:]]*$ ]] && [[ "$in_development" == true ]]; then
            if [[ ! "$line" =~ ^[[:space:]]*install_scripts:[[:space:]]*$ ]]; then
                break
            fi
        fi
        
        # Check for install_scripts section within development
        if [[ "$in_development" == true && "$line" =~ ^[[:space:]]*install_scripts:[[:space:]]*$ ]]; then
            in_install_scripts=true
            continue
        fi
        
        # Parse script entries
        if [[ "$in_install_scripts" == true ]]; then
            # New script entry
            if [[ "$line" =~ ^[[:space:]]*-[[:space:]]*name:[[:space:]]*['\"]?([^'\"]+)['\"]?[[:space:]]*$ ]]; then
                # Save previous script if complete
                if [[ -n "$current_name" && -n "$current_url" ]]; then
                    scripts+=("$current_name|$current_url|$current_args")
                fi
                current_name="${BASH_REMATCH[1]}"
                current_url=""
                current_args=""
            elif [[ "$line" =~ ^[[:space:]]*url:[[:space:]]*['\"]?([^'\"]+)['\"]?[[:space:]]*$ ]]; then
                current_url="${BASH_REMATCH[1]}"
            elif [[ "$line" =~ ^[[:space:]]*args:[[:space:]]*['\"]?([^'\"]*)['\"]?[[:space:]]*$ ]]; then
                current_args="${BASH_REMATCH[1]}"
            fi
        fi
    done < "$file"
    
    # Save last script if complete
    if [[ -n "$current_name" && -n "$current_url" ]]; then
        scripts+=("$current_name|$current_url|$current_args")
    fi
    
    printf '%s\n' "${scripts[@]}"
}

# Update system first
echo "üì¶ Updating system packages..."
sudo apt update

# Read package lists from chezmoi data
PACKAGES_FILE="{{ .chezmoi.sourceDir }}/.chezmoidata/packages.yaml"

if [ ! -f "$PACKAGES_FILE" ]; then
    echo "‚ùå Packages file not found: $PACKAGES_FILE"
    exit 1
fi

# Install APT packages from ubuntu section
echo "üì¶ Installing APT packages..."
APT_PACKAGES=($(parse_nested_yaml_section "$PACKAGES_FILE" "ubuntu" "apt"))
if [ ${#APT_PACKAGES[@]} -gt 0 ]; then
    for package in "${APT_PACKAGES[@]}"; do
        [[ -n "$package" ]] && install_apt_package "$package" || true
    done
else
    echo "‚ÑπÔ∏è No APT packages specified, skipping..."
fi

# Install Snap packages (regular)
echo "üì¶ Installing regular Snap packages..."
SNAP_REGULAR_PACKAGES=($(parse_nested_yaml_section "$PACKAGES_FILE" "regular" ""))
# Try alternative path for nested structure
if [ ${#SNAP_REGULAR_PACKAGES[@]} -eq 0 ]; then
    # Parse ubuntu.snap.regular
    SNAP_REGULAR_PACKAGES=($(awk '
    /^[[:space:]]*ubuntu:/ { in_ubuntu = 1; next }
    /^[[:space:]]*[a-zA-Z_]/ && in_ubuntu && !/^[[:space:]]*snap:/ { in_ubuntu = 0 }
    in_ubuntu && /^[[:space:]]*snap:/ { in_snap = 1; next }
    in_ubuntu && in_snap && /^[[:space:]]*regular:/ { in_regular = 1; next }
    in_ubuntu && in_snap && /^[[:space:]]*[a-zA-Z_]/ && in_regular && !/^[[:space:]]*regular:/ { in_regular = 0 }
    in_regular && /^[[:space:]]*-/ { 
        gsub(/^[[:space:]]*-[[:space:]]*/, ""); 
        gsub(/^["\047]|["\047]$/, ""); 
        if (length($0) > 0) print $0 
    }
    ' "$PACKAGES_FILE"))
fi

if [ ${#SNAP_REGULAR_PACKAGES[@]} -gt 0 ]; then
    for package in "${SNAP_REGULAR_PACKAGES[@]}"; do
        if [[ -n "$package" ]]; then
            echo "Installing $package via snap..."
            if command_exists snap && sudo snap install "$package" 2>/dev/null; then
                echo "‚úÖ $package installed via snap"
            else
                echo "‚ö†Ô∏è Failed to install $package via snap"
            fi
        fi
    done
else
    echo "‚ÑπÔ∏è No regular Snap packages specified, skipping..."
fi

# Install Snap packages (classic)
echo "üì¶ Installing classic Snap packages..."
SNAP_CLASSIC_PACKAGES=($(awk '
/^[[:space:]]*ubuntu:/ { in_ubuntu = 1; next }
/^[[:space:]]*[a-zA-Z_]/ && in_ubuntu && !/^[[:space:]]*snap:/ { in_ubuntu = 0 }
in_ubuntu && /^[[:space:]]*snap:/ { in_snap = 1; next }
in_ubuntu && in_snap && /^[[:space:]]*classic:/ { in_classic = 1; next }
in_ubuntu && in_snap && /^[[:space:]]*[a-zA-Z_]/ && in_classic && !/^[[:space:]]*classic:/ { in_classic = 0 }
in_classic && /^[[:space:]]*-/ { 
    gsub(/^[[:space:]]*-[[:space:]]*/, ""); 
    gsub(/^["\047]|["\047]$/, ""); 
    if (length($0) > 0) print $0 
}
' "$PACKAGES_FILE"))

if [ ${#SNAP_CLASSIC_PACKAGES[@]} -gt 0 ]; then
    for package in "${SNAP_CLASSIC_PACKAGES[@]}"; do
        if [[ -n "$package" ]]; then
            echo "Installing $package via snap --classic..."
            if command_exists snap && sudo snap install "$package" --classic 2>/dev/null; then
                echo "‚úÖ $package installed via snap --classic"
            else
                echo "‚ö†Ô∏è Failed to install $package via snap --classic"
            fi
        fi
    done
else
    echo "‚ÑπÔ∏è No classic Snap packages specified, skipping..."
fi

# Install Flatpak packages
echo "üì¶ Installing Flatpak packages..."
FLATPAK_PACKAGES=($(parse_nested_yaml_section "$PACKAGES_FILE" "ubuntu" "flatpak"))
if [ ${#FLATPAK_PACKAGES[@]} -gt 0 ]; then
    # Ensure flatpak is installed
    if ! command_exists flatpak; then
        install_apt_package "flatpak"
        sudo flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo
    fi
    
    for package in "${FLATPAK_PACKAGES[@]}"; do
        if [[ -n "$package" ]]; then
            echo "Installing $package via flatpak..."
            if sudo flatpak install -y flathub "$package" 2>/dev/null; then
                echo "‚úÖ $package installed via flatpak"
            else
                echo "‚ö†Ô∏è Failed to install $package via flatpak"
            fi
        fi
    done
else
    echo "‚ÑπÔ∏è No Flatpak packages specified, skipping..."
fi

# Install development tools via install scripts
echo "üì¶ Installing development tools via install scripts..."
INSTALL_SCRIPTS=($(parse_install_scripts "$PACKAGES_FILE"))
if [ ${#INSTALL_SCRIPTS[@]} -gt 0 ]; then
    for script_info in "${INSTALL_SCRIPTS[@]}"; do
        IFS='|' read -r name url args <<< "$script_info"
        if [[ -n "$name" && -n "$url" ]]; then
            if ! command_exists "$name"; then
                echo "Installing $name..."
                if [[ "$args" == *"|"* ]]; then
                    # Handle piped commands
                    eval "curl -fsSL '$url' $args"
                else
                    # Handle regular arguments
                    curl -fsSL "$url" | sh $args
                fi
                if [ $? -eq 0 ]; then
                    echo "‚úÖ $name installed successfully"
                else
                    echo "‚ö†Ô∏è Failed to install $name"
                fi
            else
                echo "‚ÑπÔ∏è $name is already installed, skipping..."
            fi
        fi
    done
else
    echo "‚ÑπÔ∏è No install scripts specified, skipping..."
fi

# Post-installation fixes
echo "üîß Applying post-installation fixes..."

# Create fd symlink if fd-find was installed
if command_exists fdfind && [ ! -f /usr/local/bin/fd ]; then
    sudo ln -s /usr/bin/fdfind /usr/local/bin/fd
    echo "‚úÖ Created fd symlink for fdfind"
fi

# Source cargo environment if rust was installed
if [ -f "$HOME/.cargo/env" ]; then
    source "$HOME/.cargo/env"
    echo "‚úÖ Sourced Rust/Cargo environment"
fi

echo "‚úÖ Development tools installation complete!"
echo "‚ÑπÔ∏è Some changes may require a logout/login or shell restart to take effect."

{{- end }}